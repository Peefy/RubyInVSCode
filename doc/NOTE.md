
# Ruby 笔记

## Ruby 简介

Ruby是一种纯粹的面向对象编程语言。它由日本的松本行弘（まつもとゆきひろ/Yukihiro Matsumoto）创建于1993年。

## Ruby 特征

* Ruby 是开源的，在 Web 上免费提供，但需要一个许可证。
* Ruby 是一种通用的、解释的编程语言。
* Ruby 是一种真正的面向对象编程语言。
* Ruby 是一种类似于 Python 和 Perl 的服务器端脚本语言。
* Ruby 可以用来编写通用网关接口（CGI）脚本。
* Ruby 可以被嵌入到超文本标记语言（HTML）。
* Ruby 语法简单，这使得新的开发人员能够快速轻松地学习 Ruby。
* Ruby 与 C++ 和 Perl 等许多编程语言有着类似的语法。
* Ruby 可扩展性强，用 Ruby 编写的大程序易于维护。
* Ruby 可用于开发的 Internet 和 Intranet 应用程序。
* Ruby 可以安装在 Windows 和 POSIX 环境中。
* Ruby 支持许多 GUI 工具，比如 Tcl/Tk、GTK 和 OpenGL。
* Ruby 可以很容易地连接到 DB2、MySQL、Oracle 和 Sybase。
* Ruby 有丰富的内置函数，可以直接在 Ruby 脚本中使用。

## Ruby语法

Ruby 文件扩展名都是 **.rb** 或者 **.ru**

*Ruby 程序中的空白*-在 Ruby 代码中的空白字符，如空格和制表符一般会被忽略，除非当它们出现在字符串中时才不会被忽略。然而，有时候它们用于解释模棱两可的语句。当启用 -w 选项时，这种解释会产生警告。

*Ruby 程序中的行尾*-Ruby 把分号和换行符解释为语句的结尾。但是，如果 Ruby 在行尾遇到运算符，比如 +、- 或反斜杠，它们表示一个语句的延续。

*Ruby 标识符*-标识符是变量、常量和方法的名称。Ruby 标识符是大小写敏感的。这意味着 Ram 和 RAM 在 Ruby 中是两个不同的标识符。Ruby 标识符的名称可以包含字母、数字和下划线字符（ _ ）。

## Ruby保留字

下表列出了 Ruby 中的保留字。这些保留字不能作为常量或变量的名称。但是，它们可以作为方法名。

保留字|保留字|保留字|保留字
-|-|-|-
BEGIN|	do|	next|	then
END|	else|	nil|	true
alias|	elsif|	not|	undef
and|	end|	or|	unless
begin|	ensure|	redo|	until
break|	false|	rescue|	when
case|	for|	retry|	while
class|	if|	return|	while
def|	in|	self|	\_\_FILE\_\_
defined?|	module|	super|	\_\_LINE\_\_

**Ruby 中的 Here Document**

"Here Document" 是指建立多行字符串。在 << 之后，您可以指定一个字符串或标识符来终止字符串，且当前行之后直到终止符为止的所有行是字符串的值。
如果终止符用引号括起，引号的类型决定了面向行的字符串类型。请注意<< 和终止符之间必须没有空格。
下面是不同的实例：

```ruby
print <<EOF
    这是第一种方式创建here document 。
    多行字符串。
EOF
 
print <<"EOF";                # 与上面相同
    这是第二种方式创建here document 。
    多行字符串。
EOF
 
print <<`EOC`                 # 执行命令
    echo hi there
    echo lo there
EOC
 
print <<"foo", <<"bar"          # 您可以把它们进行堆叠
    I said foo.
foo
    I said bar.
bar
```

**Ruby的BEGIN 语句**

```ruby
puts "这是主 Ruby 程序"
 
BEGIN {
   puts "初始化 Ruby 程序"
}
```

**Ruby的BEGIN 语句**

```ruby
#!/usr/bin/ruby
 
puts "这是主 Ruby 程序"
 
END {
   puts "停止 Ruby 程序"
}
BEGIN {
   puts "初始化 Ruby 程序"
}
```

**Ruby 注释**

注释会对 Ruby 解释器隐藏一行，或者一行的一部分，或者若干行。可以在行首使用字符（ # ）：

```ruby
name = "Madisetti" # 这也是注释
```

下面是另一种形式。这种块注释会对解释器隐藏 =begin/=end 之间的行：

```ruby
=begin
注释行1
注释行2
=end
```

**Ruby数据类型**

Ruby支持的类型包括基本的**Number**、**String**、**Ranges**、**Symbols**，以及**true**、**false**和**nil**这几个特殊值，同时还有两种重要的数据结构**Array**和**Hash**

**整型(Integer)**

整型分两种，如果在31位以内（四字节），那为`Fixnum`实例。如果超过，即为`Bignum`实例。

整数范围从 -2^30 到 2^30-1，在这个范围内的整数是类 `Fixnum` 的对象， 当整数值大于或等于2的30次方时（ -2^62 到 2^62-1），会自动转化为 `Bignum` 类型。

可以在整数前使用一个可选的前导符号，一个可选的基础指标（`0` 对应 `octal`，`0x` 对应 `hex`，`0b` 对应 `binary`），后跟一串数字。下划线字符在数字字符串中被忽略。

您可以获取一个 ASCII 字符或一个用问号标记的转义序列的整数值。

```ruby
123                  # Fixnum 十进制
1_234                # Fixnum 带有下划线的十进制
-500                 # 负的 Fixnum
0377                 # 八进制
0xff                 # 十六进制
0b1011               # 二进制
"a".ord              # "a" 的字符编码
?\n                  # 换行符（0x0a）的编码
12345678901234567890 # 大数
 
#整型 Integer 以下是一些整型字面量 
#字面量（literal）：代码中能见到的值，数值，bool值，字符串等都叫字面量 
#如以下的0,1_000_000,0xa等 
a1=0 
 
#带千分符的整型 
a2=1_000_000 
 
#其它进制的表示 
a3=0xa 
puts a1,a2 
puts a3 
 
#puts print 都是向控制台打印字符，其中puts带回车换行符 
=begin 
这是注释，称作：嵌入式文档注释 
类似C#中的/**/ 
=end
```

**浮点型**

Ruby 支持浮点数。它们是带有小数的数字。浮点数是类 Float 的对象，且可以是下列中任意一个。

```ruby
123.4                # 浮点值
1.0e6                # 科学记数法
4E20                 # 不是必需的
4e+20                # 指数前的符号
 
#浮点型 
f1=0.0 
f2=2.1 
f3=1000000.1 
puts f3
```

**算术操作**

加减乘除操作符：+-*/；指数操作符为**

指数不必是整数，例如

```ruby
#指数算术 
puts 2**(1/4)#1与4的商为0，然后2的0次方为1 
puts 16**(1/4.0)#1与4.0的商为0.25（四分之一），然后开四次方根
```

**字符串类型**

Ruby 字符串简单地说是一个 8 位字节序列，它们是类 String 的对象。

双引号标记的字符串允许替换和使用反斜线符号，单引号标记的字符串不允许替换，且只允许使用 \\\\ 和 \\' 两个反斜线符号。

```ruby
#!/usr/bin/ruby -w
 
puts 'escape using "\\"';
puts 'That\'s right';
```

可以使用序列 #{ expr } 替换任意 Ruby 表达式的值为一个字符串。在这里，expr 可以是任意的 Ruby 表达式。

```ruby
puts "相乘 : #{24*60*60}";
```

**反斜线符号**

符号|表示的字符
-|-
\\n	|换行符 (0x0a)
\\r	|回车符 (0x0d)
\\f	|换页符 (0x0c)
\\b	|退格键 (0x08)
\\a	|报警符 Bell (0x07)
\\e	|转义符 (0x1b)
\\s	|空格符 (0x20)
\\nnn	|八进制表示法 (n 是 0-7)
\\xnn	|十六进制表示法 (n 是 0-9、a-f 或 A-F)
\\cx, \\C-x	|Control-x
\\M-x	|Meta-x (c | 0x80)
\\M-\\C-x	|Meta-Control-x
\\x	|字符 x

**Ruby数组**

数组字面量通过[]中以逗号分隔定义，且支持range定义。

* 数组通过[]索引访问
* 通过赋值操作插入、删除、替换元素
* 通过+，－号进行合并和删除元素，且集合做为新集合出现
* 通过<<号向原数据追加元素
* 通过*号重复数组元素
* 通过｜和&符号做并集和交集操作（注意顺序）

```ruby
ary = [ "fred", 10, 3.14, "This is a string", "last element", ]
ary.each do |i|
    puts i
end
```

**Ruby哈希类型**

Ruby 哈希是在大括号内放置一系列键/值对，键和值之间使用逗号和序列 => 分隔。尾部的逗号会被忽略。

```ruby
hsh = colors = { "red" => 0xf00, "green" => 0x0f0, "blue" => 0x00f }
hsh.each do |key, value|
    print key, " is ", value, "\n"
end
```

**Ruby范围类型**

一个范围表示一个区间。

范围是通过设置一个开始值和一个结束值来表示。范围可使用 s..e 和 s...e 来构造，或者通过 Range.new 来构造。
使用 .. 构造的范围从开始值运行到结束值（包含结束值）。使用 ... 构造的范围从开始值运行到结束值（不包含结束值）。当作为一个迭代器使用时，范围会返回序列中的每个值。

范围 (1..5) 意味着它包含值 1, 2, 3, 4, 5，范围 (1...5) 意味着它包含值 1, 2, 3, 4 。

```ruby
(10..15).each do |n|
    print n, ' '
end
```

**Ruby类和对象**

Ruby是一种完美的面向对象的编程语言。面向对象编程语言的特性包括：

* 数据封装
* 数据抽象
* 多态性
* 继承

在Ruby中，类总是以关键字class开始，后面跟类的名称。类名的首字母应该大写。类Customer如下所示：

```ruby
class Customer
end
```

**Ruby类中的变量**

* **局部变量**-局部变量是在方法中定义的变量。局部变量在方法外是不可用的。局部变量以小写字母或\_开始
* **实例变量**-实例变量可以跨任何特性的实例或对象中的方法使用。这意味着，实例变量可以从对象到对象的改变。实例变量在变量名之前放置符号(@)
* **类变量**-类变量可以跨不同的对象使用。类变量属于类，且类是一个属性。类变量在变量名之前放置符号(@@)
* **全局变量**-类变量不能跨类使用，如果想要一个可以跨类使用的变量，需要定义全局变量。全局变量总是以美元符号($)开始

```ruby
class Customer
    @@no_of_customers = 0
end
```

**在Ruby中使用new方法创建对象**

对象是类的实例。在Ruby中可以使用类的方法new创建对象，方法`new`是一种独特的方法，在Ruby库中预定义，`new`方法属于类方法。

```ruby
cust1 = Customer. new
cust2 = Customer. new
```

上述代码中，cust1和cust2是两个对象的名称。对象名称后跟着等号(=),等号后面跟着类名，然后是点运算符和关键字`new`

**自定义方法来创建Ruby**

可以给方法`new`传递参数，这些参数可用于初始化类变量。当想要声明带参数的`new`方法时，需要在创建类的同时声明方法`initialize`。`initialize`方法是一种特殊类型的方法，将在参数调用带参数的类型的`new`方法时执行。

```ruby
class Customer
    @@no_of_customers = 0
    def initialize(id, name, addr)
        @cust_id = id
        @cust_name = name
        @cust_addr = addr
    end
end
```

```ruby
cust1 = Customer.new("1", "John", "Wisdom Apartments, Ludhiya")
cust2 = Customer.new("2", "Poul", "New Empire road, Khandala")
```

**Ruby类中的成员函数**

在Ruby中，函数被称为方法。类中的每个方法是以关键字`def`开始，后跟方法名。方法名总是以**小写字母**开头。在Ruby中，可以使用关键字`end`来结束一个方法

```ruby
class Sample
    def hello
        puts "Hello Ruby!"
    end
end

obj = Sample. new
obj.hello
```

```ruby
class Customer
    @@no_of_customers = 0
    def initialize(id, name, addr)
        @cust_id = id
        @cust_name = name
        @cust_addr = addr
    end
    def display_details()
        puts "Customer id #@cust_id"
        puts "Customer name #@cust_name"
        puts "Customer address #@cust_addr"
    end
    def total_no_of_customers()
        @@no_of_customers += 1
        puts "Total number of customers: #@@no_of_customers"
    end
end
```

上述代码第一个方法`display_details`方法包含了三个`puts`语句，显示了客户ID、客户名字和客户地址。其中，`puts`语句将在一个单行上显示实例变量的文本和值时，需要在`puts`语句的变量名前面放置符号(`#`)。文本和带有符号(`#`)的实例变量应使用双引号标记。

第二个方法,`total_no_of_customers`包含了类变量`@@no_of_customers += 1`在每次调用方法`total_no_of_customers`时，把变量`no_of_customers`加1。通过这种方式，将得到类变量中的客户总数量。

**Ruby变量**

变量是持有可被任何程序使用的任何数据的存储位置。

Ruby支持五种类型的变量。

* 一般小写字母、下划线开头：变量(Variable)
* `$`开头：全局变量(Global variable)
* `@`开头：实例变量(Instance variable)
* `@@`开头：类变量(Class variable)类变量被共享在整个继承链中
* 大写字母开头：常数(Constant)

**Ruby全局变量**

全局变量以`$`开头。未初始化的全局变量的值为`nil`，在使用`-w`选项后，会产生警告。给全局变量赋值会改变全局状态，所以不建议使用全局变量。

```ruby
$global_variable = 10
class Class1
    def print_global
        puts "全局变量在 Class1 中输出为 #$global_variable"
    end
end

class Class2
    def print_global
        puts "全局变量在 Class2 中输出为 #$global_variable"
    end
end

class1obj = Class1.new
class1obj.print_global
class2obj = Class2.new
class2obj.print_global
```

注意：在Ruby中，您可以通过在变量或常量前面放置`#`字符，来访问任何变量或常量的值

**Ruby实例变量**

实例变量`@`开头。未初始化的实例变量为`nil`,在使用`-w`选项，会产生警告

下面的实例显示了实例变量的用法

**Ruby类变量**

类变量以@@开头，且必须初始化后才能方法定义中使用。引用一个未初始化的类变量会产生错误。类变量在定义它的类或模块的子类或子模块中可共享使用。在使用`-w`选项，重载类变量会产生警告。

**Ruby局部变量**

局部变量以小写字母或下划线_开头。局部变量的作用域`class`,`module`,`def`或`do`到相应的结尾或者从左大括号到右大括号{}。

当调用一个未初始化的局部变量时，它被解释为调用一个不带参数的方法。

对于未初始化的局部变量赋值也可当作是变量声明。变量会一直存在，直到当前域结束为止。局部变量的生命周期在 Ruby 解析程序时确定。

**Ruby常量**

常量以大写字母开头。定义在类或模块内的常量可以从类或模块的内部访问，定义在类或模块外的常量可以被全局访问。

常量不能定义在方法内。引用一个未初始化的常量会产生错误。对已经初始化的常量赋值会产生警告。

```ruby
class Example
   VAR1 = 100
   VAR2 = 200
   def show
       puts "第一个常量的值为 #{VAR1}"
       puts "第二个常量的值为 #{VAR2}"
   end
end
 
# 创建对象
object=Example.new()
object.show
```

**Ruby 伪变量**

它们是特殊的变量，有着局部变量的外观，但行为却像常量。您不能给这些变量赋任何值。

* **self**-当前方法的接收器对象。
* **true**-代表 true 的值。
* **false**-代表 false 的值。
* **nil**-代表 undefined 的值。
* **__FILE__**-当前源文件的名称。
* **__LINE__**-当前行在源文件中的编号。

**Ruby运算符**

Ruby支持一套丰富的运算符。大多数运算符实际上方法调用。例如，`a + b`被解释为`a .+(b)`,其中指向变量`a`的`+`方法被调用，`b`作为方法调用的参数。

对于每个运算符(`+ - * / % ** & | ^ << >> && ||`),都有一个相对应的缩写赋值运算符(`+= -=`)等等

**Ruby算术运算符**

假设变量 `a` 的值为 `10`，变量 `b` 的值为 `20`，那么：

运算符|描述|实例
-|-|-
`+`	|加法 - 把运算符两边的操作数相加|	`a + b` 将得到 `30`
`-`	|减法 - 把左操作数减去右操作数|	`a - b` 将得到 `-10`
`*`	|乘法 - 把运算符两边的操作数相乘|	`a * b` 将得到 `200`
`/`	|除法 - 把左操作数除以右操作数|	`b / a` 将得到 `2`
`%`	|求模 - 把左操作数除以右操作数，返回余数|	`b % a` 将得到 `0`
`**`	|指数 - 执行指数计算|	`a**b` 将得到 `10` 的 `20` 次方

**Ruby比较运算符**

假设变量 `a` 的值为 `10`，变量 `b` 的值为 `20`，那么：

运算符|描述|实例
-|-|-
`==`	|检查两个操作数的值是否相等，如果相等则条件为真。|	`(a == b)` 不为真。
`!=`	|检查两个操作数的值是否相等，如果不相等则条件为真。|	`(a != b)` 为真。
`>`	|检查左操作数的值是否大于右操作数的值，如果是则条件为真。|	`(a > b)` 不为真。
`<`	|检查左操作数的值是否小于右操作数的值，如果是则条件为真。|	`(a < b)` 为真。
`>=`	|检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。|	`(a >= b)` 不为真。
`<=`	|检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。|	`(a <= b)` 为真。
`<=>`	|联合比较运算符。如果第一个操作数等于第二个操作数则返回 0，如果第一个操作数大于第二个操作数则返回 1，如果第一个操作数小于第二个操作数则返回 -1。|	`(a <=> b)` 返回 -1。
`===`	|用于测试 `case` 语句的 `when` 子句内的相等。	`(1...10) === 5` 返回 `true`。
`.eql?`	|如果接收器和参数具有相同的类型和相等的值，则返回 `true`。|	`1 == 1.0` 返回 `true`，但是 `1.eql?(1.0)` 返回 `false`。
`equal?`	|如果接收器和参数具有相同的对象 `id`，则返回 `true`。	如果 `aObj` 是 `bObj` 的副本，那么 `aObj == bObj` 返回 `true`，`a.equal?bObj` 返回 `false`，但是 `a.equal?aObj` 返回 true。

**Ruby赋值运算符**

假设变量 `a` 的值为 `10`，变量 `b` 的值为 `20`，那么：

运算符|描述|实例
-|-|-
`=`	|简单的赋值运算符，把右操作数的值赋给左操作数|	`c = a + b` 将把 `a + b` 的值赋给 `c`
`+=`	|加且赋值运算符，把右操作数加上左操作数的结果赋值给左操作数|	`c += a` 相当于 `c = c + a`
`-=`	|减且赋值运算符，把左操作数减去右操作数的结果赋值给左操作数|	`c -= a` 相当于 `c = c - a`
`*=`	|乘且赋值运算符，把右操作数乘以左操作数的结果赋值给左操作数|	`c *= a` 相当于 `c = c * a`
`/=`	|除且赋值运算符，把左操作数除以右操作数的结果赋值给左操作数|	`c /= a` 相当于 `c = c / a`
`%=`	|求模且赋值运算符，求两个操作数的模赋值给左操作数|	`c %= a` 相当于 `c = c % a`
`**=`	|指数且赋值运算符，执行指数计算，并赋值给左操作数|	`c **= a` 相当于 `c = c ** a`

**Ruby的并行赋值**

Ruby 也支持变量的并行赋值。这使得多个变量可以通过一行的 Ruby 代码进行初始化。

```ruby
a, b, c = 10, 20, 30
a, b = b, a
```

**Ruby位运算符**

位运算符作用于位，并逐位执行操作

假设如果 `a = 60`，且 `b = 13`，现在以二进制格式：

`a = 0011 1100`

`b = 0000 1101`

-----------------

`a&b = 0000 1100`

`a|b = 0011 1101`

`a^b = 0011 0001`

`~a  = 1100 0011`

运算符|描述|实例
-|-|-
`&`	|如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。|	`(a & b)` 将得到 `12`，即为 `0000 1100`
`|`	|如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。|	`(a | b)` 将得到 `61`，即为 `0011 1101`
`^`	|如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。|	`(a ^ b)` 将得到 `49`，即为 `0011 0001`
`~`	|二进制补码运算符是一元运算符，具有"翻转"位效果，即0变成1，1变成0。	`(~a)` 将得到 `-61`，即为 `1100 0011`，一个有符号二进制数的补码形式。|
`<<`	|二进制左移运算符。左操作数的值向左移动右操作数指定的位数。|	`a << 2` 将得到 `240`，即为 `1111 0000`
`>>`	|二进制右移运算符。左操作数的值向右移动右操作数指定的位数。|	`a >> 2` 将得到 `15`，即为 `0000 1111`

**Ruby逻辑运算符**

假设变量 `a` 的值为 `10`，变量 `b` 的值为 `20`，那么：

运算符|描述|实例
-|-|-
`and`	|称为逻辑与运算符。如果两个操作数都为真，则条件为真。|	`(a and b)` 为真。
`or`	|称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。|	`(a or b)` 为真。
`&&`	|称为逻辑与运算符。如果两个操作数都非零，则条件为真。|	`(a && b)` 为真。
`||`	|称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。|	`(a || b)` 为真。
`!`	|称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。|	`!(a && b)` 为假。
`not`	|称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。|	`not(a && b)` 为假。

**Ruby三元运算符**

有一个以上的操作称为三元运算符。第一个计算表达式的真假值，然后根据这个结果决定执行后边两个语句中的一个。条件运算符的语法如下：

运算符|描述|实例
-|-|-
`?X:Y`	|条件表达式	|如果条件为真 `?` 则值为 `X` `:` 否则值为 `Y`

**Ruby 范围运算符**

在 Ruby 中，序列范围用于创建一系列连续的值 - 包含起始值、结束值（视情况而定）和它们之间的值。

在 Ruby 中，这些序列是使用 ".." 和 "..." 范围运算符来创建的。两点形式创建的范围包含起始值和结束值，三点形式创建的范围只包含起始值不包含结束值。

运算符|描述|实例
-|-|-
`..`	|创建一个从开始点到结束点的范围（包含结束点）|	`1..10` 创建从 `1` 到 `10` 的范围
`...`	|创建一个从开始点到结束点的范围（不包含结束点）|	`1...10` 创建从 `1` 到 `9` 的范围

**Ruby defined? 运算符**

defined? 是一个特殊的运算符，以方法调用的形式来判断传递的表达式是否已定义。它返回表达式的描述字符串，如果表达式未定义则返回 nil。

下面是 defined? 运算符的各种用法：

```ruby
foo = 42
defined? foo    # => "local-variable"
defined? $_     # => "global-variable"
defined? bar    # => nil（未定义）

defined? puts        # => "method"
defined? puts(bar)   # => nil（在这里 bar 未定义）
defined? unpack      # => nil（在这里未定义）

defined? super     # => "super"（如果可被调用）
defined? super     # => nil（如果不可被调用）

defined? yield    # 如果已传递代码块，则为 True

defined? yield    # => "yield"（如果已传递块）
defined? yield    # => nil（如果未传递块）
```

**Ruby 点运算符 "." 和双冒号运算符 "::"**

可以通过在方法名称前加上类或模块名称和`.`来调用类或模块中的方法，可以使用类或模块名称和两个冒号`::`来应用类或者模块中的常量

`::`是一元运算符，允许在类或模块内定义常量、实例方法和类方法，可以从类或模块外的任何地方进行访问。

*注意：在Ruby中，类和方法也可以被当做常量*

只需要在表达式的常量名前加上`::`前缀，即可返回适当的类或模块对象。

如果`::`前的表达式为类或模块名称，则返回该类或模块内对应的常量值，如果`::`前未没有前缀表达式，则返回主Object类中对应的常量值

```ruby
MR_COUNT = 0
module Foo
    MR_COUNT = 0
    ::MR_COUNT = 1
    MR_COUNT = 2
end
puts MR_COUNT
puts Foo::MR_COUNT
```

```ruby
CONST = ' out here'
class Inside_one
    CONST = proc {' in here'}
    def where_is_my_CONST
        ::CONST + ' inside one'
    end
end
class Inside_two
    CONST = ' inside two'
    def where_is_my_CONST
        CONST
    end
end
puts Inside_one.new.where_is_my_CONST
puts Inside_two.new.where_is_my_CONST
puts Object::CONST + Inside_two::CONST
puts Inside_two::CONST + CONST
puts Inside_one::CONST
puts Inside_one::CONST.call + Inside_two::CONST
```

**Ruby运算符的优先级**

方法|运算符|描述
-|-|-
是|	`::`	|常量解析运算符
是|	`[ ] [ ]=`	|元素引用、元素集合
是|	`**`	|指数
是|	`! ~ + -`	|非、补、一元加、一元减（最后两个的方法名为 `+@` 和 `-@`）
是|	`* / %`	|乘法、除法、求模
是|	`+ -`	|加法和减法
是|	`>> <<`	|位右移、位左移
是|	`&`	|位与
是|	`^ |`	|位异或、位或
是|	`<= < > >=`	|比较运算符
是|	`<=> == === != =~ !~`	|相等和模式匹配运算符（`!=` 和 `!~` 不能被定义为方法）
-| `&&`	|逻辑与
-| `||`	|逻辑或
-| `..` `...`	|范围（包含、不包含）
-| `? :`	|三元 `if-then-else`
-| `= %= { /= -= += |= &= >>= <<= *= &&= ||= **=`	|赋值
-| `defined?`	|检查指定符号是否已定义
-| `not`	|逻辑否定
-| `or and`	|逻辑组成
